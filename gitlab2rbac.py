#!/usr/bin/python env

import logging
from os import environ
from time import sleep

import kubernetes
from gitlab import Gitlab

logging.basicConfig(format='%(asctime)s - %(levelname)s- %(message)s',
                    level=logging.INFO)


class GitlabHelper(object):

    ACCESS_LEVEL_REFERENCE = {
        10: 'guest',
        20: 'reporter',
        30: 'developer',
        40: 'maintainer',
        50: 'owner'
    }

    def __init__(self, url, token, timeout, group):
        self.client = None
        self.gitlab_users = []
        self.group = group
        self.timeout = timeout
        self.token = token
        self.url = url

    def connect(self):
        """Performs an authentication via private token.

        Raises:
            exception: If any errors occurs.
        """
        try:
            self.client = Gitlab(url=self.url, private_token=self.token,
                                 timeout=self.timeout)
            self.client.auth()
        except Exception as e:
            raise Exception('unable to connect on gitlab :: {}'.format(e))

    def get_projects(self):
        """Get all projects unders the configured namespace (GITLAB_GROUP_SEARCH).

        Returns:
            list[gitlab.Project]: list for success, empty otherwise.
        """
        try:
            projects = []
            for group in self.client.groups.list(search=self.group, all=True):
                logging.info('search group={}'.format(group.name))
                for project in group.projects.list(all=True):
                    projects.append(self.client.projects.get(project.id))
                    logging.info('|_ search group={} project={}'.format(group.name, project.name))
            return projects
        except Exception as e:
            logging.exception('unable to get groups :: {}'.format(e))
            return []

    def get_users(self):
        """Returns all users from self.get_projects.

        e.g. user {
                'access_level': 'reporter',
                'email': 'foo@bar.com',
                'id': '123',
                'namespace': 'default'
            }

        Returns:
            list[dict]: list for success, empty otherwise.
        """
        try:
            users = []
            for project in self.get_projects():
                for member in project.members.list():
                    user = self.client.users.get(member.id)
                    users.append({
                        'access_level': member.access_level,
                        'email': user.email,
                        'id': '{}'.format(user.id),
                        'namespace': project.name
                    })
                    logging.info("|__ found user={} email={} access_level={}".format(user.name, user.email, member.access_level))
            return users
        except Exception as e:
            logging.exception('unable to retrieve users :: {}'.format(e))
            return []

    def create_auto_rbac(self, namespaces):
        """Create all related stuff for gitlab2rbac (group, projects).

        Args:
            namespaces (list): The name of all namespaces from kubernetes.

        Returns:
            bool: list for succes, empty otherwise.
        """
        try:
            # NOTE: we use list method instead of get to avoid 404 exception
            for group in self.client.groups.list(search=self.group):
                if group.name == self.group:
                    break
            else:
                group = self.client.groups.create({
                    'name': self.group,
                    'path': self.group,
                    'description': 'generated by gitlab2rbac',
                    'request_access_enabled': True,
                    'shared_runners_enabled': False,
                    'visibility': 'internal',
                })
                logging.info('auto-create group={}'.format(group.name))
            for namespace in namespaces:
                for project in self.client.projects.list(search=namespace):
                    if project.namespace['name'] != self.group:
                        continue

                    if project.name == namespace:
                        break
                else:
                    project = self.client.projects.create({
                        'name': namespace,
                        'namespace_id': group.id,
                        'description': 'generated by gitlab2rbac',
                        'visibility': 'internal',
                        'issues_enabled': False,
                        'jobs_enabled': False,
                        'merge_requests_enabled': False,
                        'request_access_enabled': True,
                        'shared_runners_enabled': False,
                        'snippets_enabled': False,
                        'wiki_enabled': False,
                    })
                    logging.info('auto-create group={} project={}'.format(group.name, project.name))
        except Exception as e:
            logging.exception('unable to create auto rbac :: {}'.format(e))


class KubernetesHelper(object):

    PROTECTED_NAMESPACES = [
        'kube-system'
    ]

    def __init__(self, load_incluster_config, user_role_prefix='gitlab2rbac'):
        self.client_rbac = None
        self.client_core = None
        self.load_incluster_config = load_incluster_config
        self.user_role_prefix = user_role_prefix

    def connect(self):
        try:
            if self.load_incluster_config:
                # it works only if this script is run by K8s as a POD
                kubernetes.config.load_incluster_config()
            else:
                kubernetes.config.load_kube_config()
            self.client_rbac = kubernetes.client.RbacAuthorizationV1Api()
            self.client_core = kubernetes.client.CoreV1Api()
        except Exception as e:
            logging.exception('unable to connect :: {}'.format(e))
            raise

    def get_namespaces(self):
        try:
            return [namespace.metadata.name for namespace in self.client_core.list_namespace().items if namespace.metadata.name not in self.PROTECTED_NAMESPACES]
        except Exception as e:
            logging.exception('unable to retrieve namespaces :: {}'.format(e))
            return []

    def check_user_role_binding(self, namespace, name):
        """Check if user_role_binding exists.

           Args:
               namespace (str): kubernetes namespace.
               name (str): user_role_binding name.

           Returns:
               bool: True if exists, False otherwise.
        """
        try:
            role_bindings = self.client_rbac.list_namespaced_role_binding(
                namespace=namespace,
                field_selector='metadata.name={}_{}'.format(self.user_role_prefix, name))
            return bool(role_bindings.items)
        except Exception as e:
            logging.exception('unable to check user role binding :: {}'.format(e))
            return False

    def create_user_role_binding(self, user, user_id, name, namespace, role_ref):
        try:
            labels = {
                'role_ref': role_ref,
                'app': self.user_role_prefix,
                # NOTE: a valid label must be an empty string or consist of alphanumeric characters
                # can't use email, this label will be usefull to search deprecated role binding
                'user_id': user_id
            }
            name = '{}_{}'.format(self.user_role_prefix, name)
            role_binding = kubernetes.client.V1RoleBinding(
                metadata=kubernetes.client.V1ObjectMeta(
                    namespace=namespace,
                    name=name,
                    labels=labels),
                subjects=[kubernetes.client.V1Subject(
                    name=user,
                    kind='User',
                    api_group='rbac.authorization.k8s.io')],
                role_ref=kubernetes.client.V1RoleRef(
                    kind='ClusterRole',
                    api_group='rbac.authorization.k8s.io',
                    name='gitlab2rbac:{}'.format(role_ref)))
            self.client_rbac.create_namespaced_role_binding(
                namespace=namespace, body=role_binding)
            logging.info('|_ role-binding created name={} namespace={}'.format(name, namespace))
        except Exception as e:
            logging.exception('unable to create user role binding :: {}'.format(e))

    def delete_deprecated_user_role_binding(self, user_id, namespace, role_ref):
        try:
            role_bindings = self.client_rbac.list_namespaced_role_binding(
                    namespace=namespace, label_selector="user_id={}".format(user_id))

            for role_binding in role_bindings.items:
                if role_binding.metadata.labels['role_ref'] == role_ref:
                    continue

                self.client_rbac.delete_namespaced_role_binding(
                        name=role_binding.metadata.name,
                        namespace=namespace,
                        body=role_binding)
                logging.info('|_ role-binding deprecated name={} namespace={}'.format(role_binding.metadata.name, namespace))
        except Exception as e:
            logging.exception('unable to delete deprecated user role binding :: {}'.format(e))

    def delete_deprecated_user_role_bindings(self, users):
        try:
            users_ids = [user['id'] for user in users]
            role_bindings = self.client_rbac.list_role_binding_for_all_namespaces()

            for role_binding in role_bindings.items:
                if not role_binding.metadata.labels:
                    continue

                if 'user_id' not in role_binding.metadata.labels:
                    continue

                if role_binding.metadata.labels['user_id'] in users_ids:
                    continue

                self.client_rbac.delete_namespaced_role_binding(
                        name=role_binding.metadata.name,
                        namespace=role_binding.metadata.namespace,
                        body=role_binding)
                logging.info('|_ role-binding deprecated name={} namespace={}'.format(role_binding.metadata.name, role_binding.metadata.namespace))
        except Exception as e:
            logging.exception('unable to delete deprecated user role binding :: {}'.format(e))


class Gitlab2RBAC(object):

    def __init__(self, gitlab, kubernetes, gitlab_auto_create):
        self.gitlab = gitlab
        self.kubernetes = kubernetes
        self.gitlab_auto_create = gitlab_auto_create
        self.gitlab_users = self.gitlab.get_users()

    def __call__(self):
        if self.gitlab_auto_create:
            self.gitlab.create_auto_rbac(namespaces=self.kubernetes.get_namespaces())

        self.create_user_role_bindings()

    def create_user_role_bindings(self):
        try:
            for user in self.gitlab_users:
                namespace = user['namespace']
                access_level = self.gitlab.ACCESS_LEVEL_REFERENCE[user['access_level']]
                role_binding_name = '{}_{}'.format(user['email'], access_level)

                if not self.kubernetes.check_user_role_binding(namespace=namespace, name=role_binding_name):
                    self.kubernetes.create_user_role_binding(
                            user=user['email'],
                            user_id=user['id'],
                            name=role_binding_name,
                            namespace=namespace,
                            role_ref=access_level)

                self.kubernetes.delete_deprecated_user_role_binding(
                        user_id=user['id'],
                        namespace=namespace,
                        role_ref=access_level)
            self.kubernetes.delete_deprecated_user_role_bindings(
                    users=self.gitlab_users)
        except Exception as e:
            logging.exception('unable to create user role bindings :: {}'.format(e))


def main():
    try:
        GITLAB_URL = environ.get('GITLAB_URL', None)
        GITLAB_PRIVATE_TOKEN = environ.get('GITLAB_PRIVATE_TOKEN', None)
        GITLAB_TIMEOUT = environ.get('GITLAB_TIMEOUT', 10)
        GITLAB_GROUP_SEARCH = environ.get('GITLAB_GROUP_SEARCH', 'gitlab2rbac')
        GITLAB_AUTO_CREATE = environ.get('GITLAB_AUTO_CREATE', True)

        KUBERNETES_LOAD_INCLUSTER_CONFIG = environ.get('KUBERNETES_LOAD_INCLUSTER_CONFIG', False)

        GITLAB2RBAC_FREQUENCY = environ.get('GITLAB2RBAC_FREQUENCY', 60)

        if not GITLAB_URL or not GITLAB_PRIVATE_TOKEN:
            logging.error('missing variables GITLAB_URL / GITLAB_PRIVATE_TOKEN')
            exit(1)

        while True:
            gitlab_helper = GitlabHelper(
                url=GITLAB_URL,
                token=GITLAB_PRIVATE_TOKEN,
                timeout=GITLAB_TIMEOUT,
                group=GITLAB_GROUP_SEARCH)
            gitlab_helper.connect()

            kubernertes_helper = KubernetesHelper(
                    load_incluster_config=KUBERNETES_LOAD_INCLUSTER_CONFIG)
            kubernertes_helper.connect()

            rbac = Gitlab2RBAC(
                    gitlab=gitlab_helper,
                    kubernetes=kubernertes_helper,
                    gitlab_auto_create=GITLAB_AUTO_CREATE)
            rbac()
            sleep(int(GITLAB2RBAC_FREQUENCY))
    except Exception as e:
        logging.exception("{}".format(e))
        exit(1)


if __name__ == "__main__":
    main()
